# 你不知道的JavaScript（上卷）

## 作用域和闭包

### 第一章 作用域是什么

#### 理解作用域

负责收集并维护由所有声明的标识符(变量)组成的一系列查询,并实施一套非常严格的规则,确定当前执行的代码对这些标识符的访问权限。  
or  
作用域是根据名称查找变量的一套规则。

#### 编译器的术语

`LHS`:赋值操作的目标是谁  
`RHS`:谁是赋值操作的源头

#### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时,就发生了作用域的嵌套。因此,在当前作用域中无法找到某个变量时,引擎就会在外层嵌套的作用域中继续查找,直到找到该变量,或抵达最外层的作用域(也就是全局作用域)为止。

遍历嵌套作用域链的规则很简单:引擎从当前的执行作用域开始查找变量,如果找不到,就向上一级继续查找。当抵达最外层的全局作用域时,无论找到还是没找到,查找过程都会停止。

#### 异常

`ReferenceError`,同作用域判别失败相关  
`TypeError`,则代表作用域判别成功了,但是对结果的操作是非法或不合理的

#### 作用域小结

作用域是一套规则,用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对变量进行赋值,那么就会使用`LHS`查询;如果目的是获取变量的值,就会使用`RHS`查询。赋值操作符会导致`LHS`查询。的赋值操作。操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
JavaScript引擎首先会在代码执行前对其进行编译,在这个过程中,像`var a=2`这样的声 明会被分解成两个独立的步骤:

1. 首先,`var a`在其作用域中声明新变量。这会在最开始的阶段,也就是代码执行前进行。
1. 接下来,`a=2`会查询(`LHS`查询)变量`a`并对其进行赋值。

`LHS`和`RHS`查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。

### 第二章 词法作用域

#### 词法阶段

简单地说,词法作用域就是定义在词法阶段的作用域。换句话说,词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的,因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。

### 第三章 函数作用域和块作用域

#### 函数中的作用域

属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。

#### 隐藏内部实现

1. 最小授权或最小暴露原则，应该最小限度地暴露必要内容,而将其他内容都“隐藏”起来,比如某个模块或对象的API设计。

1. 避免同名标识符之间的冲突

#### 立即执行函数表达式

IIFE,代表立即执行函数表达式(Immediately Invoked Function Expression)

### 第四章 提升

包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。只有声明本身会被提升,而赋值或其他运行逻辑会留在原地。  
每个作用域 都会进行提升操作。

```js
foo(); // 不是 ReferenceError, 而是 TypeError!
var foo = function bar() {
// ...
};
```

```js
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
// ...
};
```

#### 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个 “重复”声明的代码中)是函数会首先被提升,然后才是变量。

```js
foo(); // 1
var foo;
function foo() {
  console.log(1);
}

foo = function () {
  console.log(2);
};
```

尽管重复的`var`声明会被忽略掉,但出现在后面的函数声明还是可以覆盖前面的。

```js
foo(); // 3
function foo() {
  console.log( 1 );
}

var foo = function () {
  console.log( 2 );
};

function foo() {
  console.log( 3 );
}
```

## `this`和对象原型

### 第一章 关于`this`

#### `this`到底是什么

之前我们说过`this`是在运行时进行绑定的,并不是在编写时绑定,它的上下文取决于函数调用时的各种条件。`this`的绑定和函数声明的位置没有任何关系,只取决于函数的调用方式。

当一个函数被调用时,会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性,会在函数执行的过程中用到。

### 第二章 `this`全面解析

#### 调用位置

调用位置就是函数在代码中被调用的位置(而不是声明的位置)。  
调用位置就在当前正在执行的函数的前一个调用中。

#### 默认绑定

#### 隐式绑定

#### 显式绑定 `call(ctx,arg) apply(ctx,arrArg)`

硬绑定`bind(ctx,defaultArg)`

#### `new`绑定

使用`new`来调用函数,或者说发生构造函数调用时,会自动执行下面的操作。

1. 创建(或者说构造)一个全新的对象。
1. 这个新对象会被执行[[原型]]连接。
1. 这个新对象会绑定到函数调用的`this`。
1. 如果函数没有返回其他对象,那么`new`表达式中的函数调用会自动返回这个新对象。

#### 优先级

现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断:

1. 函数是否在`new`中调用(`new`绑定)?如果是的话`this`绑定的是新创建的对象。
1. 函数是否通过`call`、`apply`(显式绑定)或者硬绑定调用?如果是的话,`this`绑定的是指定的对象。
1. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,`this`绑定的是那个上下文对象。
1. 如果都不是的话,使用默认绑定。如果在严格模式下,就绑定到`undefined`,否则绑定到全局对象。

#### `this`词法

箭头函数的绑定无法被修改。

#### `this`小结

如果要判断一个运行中函数的`this`绑定,就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断`this`的绑定对象。

1. 由`new`调用?绑定到新创建的对象。
2. 由`call`或者`apply`(或者`bind`)调用?绑定到指定的对象。
3. 由上下文对象调用?绑定到那个上下文对象。
4. 默认:在严格模式下绑定到`undefined`,否则绑定到全局对象。

一定要注意,有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略`this`绑定,你可以使用一个DMZ对象,比如`ø=Object.create(null)`,以保护全局对象。

ES6中的箭头函数并不会使用四条标准的绑定规则,而是根据当前的词法作用域来决定`this`,具体来说,箭头函数会继承外层函数调用的`this`绑定(无论`this`绑定到什么)。这其实和ES6之前代码中的`self=this`机制一样。

### 第三章 对象

#### 语法

对象可以通过两种形式定义:声明(文字)形式和构造形式。  
构造形式和文字形式生成的对象是一样的。唯一的区别是,在文字声明中你可以添加多个 键 / 值对,但是在构造形式中你必须逐个添加属性。

#### 类型

简单基本类型(string、boolean、number、null和undefined)和复杂基本类型(object)

JavaScript中有许多特殊的对象子类型,我们可以称之为复杂基本类型。

#### 内置对象

JavaScript 中还有一些对象子类型, 通常被称为内置对象。  
但是在JavaScript中,它们实际上只是一些内置函数。这些内置函数可以当作构造函数来使用,从而可以构造一个对应子类型的新对象。

```js
String
Number
Boolean
Object
Function
Array
Date
RegExp
Error
```

#### 复制对象

深拷贝  
`var newObj = JSON.parse( JSON.stringify( someObj ) );`

浅拷贝  
`var newObj = Object.assign( {}, myObject );`

#### 属性描述符

```js
Object.getOwnPropertyDescriptor("object","property")
Object.defineProperty("object","property",{
  value:val,
  writable:true,  //是否可以修改属性的值
  enumberable:true,  //是否枚举
  configurable:true //是否可配置，除了无法修改, configurable:false 还会禁止删除这个属性
})
```

#### 不变性

很重要的一点是, 所有 的方法创建的都是浅不变形,也就是说,它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数,等),其他对象的内容不受影响,仍然是可变的。

- 对象常量

结合`writable:false`和`configurable:false`就可以创建一个真正的常量属性(不可修改、重定义或者删除):

```js
var myObject = {};
Object.defineProperty(myObject, "FAVORITE_NUMBER", {
  value: 42,
  writable: false ,
  configurable: false
});
```

- 禁止扩展

如果你想禁止一个对象添加新属性并且保留已有属性,可以使用`Object.preventExtensions(..)` :

```js
var myObject = {
  a:2
};
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
```

- 密封

`Object.seal(..)` 会创建一个“密封”的对象, 这个方法实际上会在一个现有对象上调用 `Object.preventExtensions(..)` 并把所有现有属性标记为 `configurable:false` 。

所以,密封之后不仅不能添加新属性,也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。

- 冻结

`Object.freeze(..)` 会创建一个冻结对象, 这个方法实际上会在一个现有对象上调用 `Object.seal(..)` 并把所有“数据访问”属性标记为 writable:false ,这样就无法修改它们 的值。

这个方法是你可以应用在对象上的级别最高的不可变性,它会禁止对于对象本身及其任意 直接属性的修改(不过就像我们之前说过的,这个对象引用的其他对象是不受影响的)。

#### 存在性

`in`操作符会检查属性是否在对象及其`[[Prototype]]`原型链中

`hasOwnProperty(..)`只会检查属性是否在对象中,不会检查`[[Prototype]]`链
